'use strict';

const { expect } = require('chai');
const { Transform } = require('stream');
const MetaPipe = require('./index');


describe('@class MetaPipe', function() {

  const pipeline = new MetaPipe({ objectMode: true });

  it('should passthrough the provided data', function() {
    pipeline.write({ foo: 'bar' });
    expect(pipeline.read()).to.deep.equal({ foo: 'bar' });
  });

  it('should append and prepend the transformers', function() {
    const tform1 = new Transform({
      transform: (data, enc, cb) => {
        data.bar = 'baz';
        cb(null, data);
      },
      objectMode: true
    });
    const tform2 = new Transform({
      transform: (data, enc, cb) => {
        data.baz = 'foo';
        cb(null, data);
      },
      objectMode: true
    });
    pipeline.append(tform1);
    pipeline.write({ foo: 'bar' });
    expect(pipeline.read()).to.deep.equal({
      foo: 'bar',
      bar: 'baz'
    });
    pipeline.prepend(tform2);
    pipeline.write({ foo: 'bar' });
    expect(pipeline.read()).to.deep.equal({
      foo: 'bar',
      bar: 'baz',
      baz: 'foo'
    });
  });

  it('should flush and end', function(done) {
    pipeline.once('end', done);
    setImmediate(() => {
      pipeline.end();
      pipeline.read();
    });
  });

  it('should bubble errors from child streams', function(done) {
    const pipeline = new MetaPipe();
    const tform3 = new Transform({
      transform: (data, enc, cb) => {
        cb(new Error('FATAL'));
      }
    });
    pipeline.append(tform3);
    pipeline.once('error', (err) => {
      expect(err.message).to.equal('FATAL');
      done();
    });
    pipeline.write('test');
  });

  it('should bubble errors from child streams', function(done) {
    const pipeline = new MetaPipe();
    const tform3 = new Transform({
      transform: (data, enc, cb) => {
        cb(new Error('FATAL'));
      }
    });
    pipeline.prepend(tform3);
    pipeline.once('error', (err) => {
      expect(err.message).to.equal('FATAL');
      done();
    });
    pipeline.write('test');
  });

  it('should tolerate errors and repipe streams', function(done) {
    const pipeline = new MetaPipe();
    const tform1 = new Transform({
      transform: (data, enc, cb) => {
        cb(null, data)
      }
    });
    const tform2 = new Transform({
      transform: function(data, enc, cb) {
        this.callCount = this.callCount || 0;
        if (this.callCount === 1) {
          this.callCount++;
          cb(new Error('ERROR'));
        } else {
          this.callCount++;
          cb(null, data);
        }
      }
    });
    const tform3 = new Transform({
      transform: (data, enc, cb) => {
        cb(null, data)
      }
    });
    pipeline.append(tform1);
    pipeline.append(tform2);
    pipeline.append(tform3);
    let received = 0;
    let errors = 0;
    pipeline.on('data', (data) => {
      expect(data.toString()).to.equal('data');
      received++;
      if (received === 2) {
        expect(errors).to.equal(1);
        done();
      }
    });
    pipeline.once('error', (err) => {
      expect(err.message).to.equal('ERROR');
      errors++;
    });
    pipeline.write('data');
    pipeline.write('data');
    pipeline.write('data');
  });

});
