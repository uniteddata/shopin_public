/**
 * @module storjd/control
 */

'use strict';

const { Stream, Transform, Readable } = require('stream');
const { v4: uuid } = require('uuid');
const { EventEmitter } = require('events');
const net = require('net');
const jsonrpc = require('jsonrpc-lite');


/**
 * A transform stream that accepts JSON RPC objects and returns newline
 * terminated JSON strings
 */
class ControlSerializer extends Transform {

  /**
   * @constructor
   */
  constructor() {
    super({ objectMode: true });
  }

  /**
   * @private
   */
  _transform(data, encoding, callback) {
    callback(null, JSON.stringify(data) + '\r\n');
  }

}

/**
 * A transform stream that splits up newline terminated JSON and returns
 * JSON-RPC objects
 */
class ControlDeserializer extends Transform {

  /**
   * @constructor
   */
  constructor() {
    super({ objectMode: true });
    this._buffer = '';
  }

  /**
   * @private
   */
  _transform(data, encoding, callback) {
    this._buffer += data.toString();

    if (this._buffer.indexOf('\r\n') === -1) {
      return callback();
    }

    let valid = true;
    let parts = this._buffer.split('\r\n');

    while (valid && parts.length) {
      let rpc = jsonrpc.parse(parts[0]);

      if (rpc.type !== 'invalid') {
        this.push(jsonrpc.parse(parts[0]));
        parts.shift();
      } else {
        valid = false;
      }
    }

    this._buffer = parts.join('\r\n');
    callback();
  }

}

/**
 * Converts a stream object into a pointer string and sets up stream tracking
 * @param {object} self - Object with a `streams` property
 * @param {object} stream
 * @param {object} serializer
 * @returns {string}
 */
function _createStreamPointer(self, stream, serializer) {
  let id = uuid();
  let readable = typeof stream.read === 'function';
  let type = readable ? 'readable' : 'writable';
  let pointer = `boscar:${type}:${id}`;

  self.streams.set(id, stream);

  if (readable) {
    _bindReadable(pointer, stream, serializer);
  }

  return pointer;
}

/**
 * Binds to readable stream events and write messages to the given serializer
 * @param {string} pointer
 * @param {object} stream
 * @param {object} serializer
 */
function _bindReadable(pointer, stream, serializer) {
  stream.on('data', (data) => {
    serializer.write(jsonrpc.notification(pointer, [data]));
  });
  stream.on('end', () => {
    serializer.write(jsonrpc.notification(pointer, [null]));
  });
  stream.on('error', () => {
    serializer.write(jsonrpc.notification(pointer, [null]));
  });
}

/**
 * Wraps a {@link Node} to provide a control interface over a socket
 */
class ControlServer extends EventEmitter {

  /**
   * @constructor
   * @param {object} api - Object implementing methods for RPC
   */
  constructor(api = {}) {
    super();

    this.api = api;
    this.clients = new Map();
    this.server = net.createServer((sock) => this.client(sock));
    this.streams = new Map();
  }

  /**
   * Bind to the supplied address and port
   * @param {number} port
   * @param {string} address
   * @param {function} callback
   */
  listen(port, address = '127.0.0.1', callback) {
    this.server.listen(port, address, callback);
  }

  /**
   * Handles incoming controller connection
   * @param {object} socket
   */
  client(socket) {
    const id = uuid();
    const serializer = new ControlSerializer();
    const deserializer = new ControlDeserializer();

    this.clients.set(id, { socket, serializer, deserializer });

    socket.on('error', () => this.clients.delete(id));
    socket.on('close', () => this.clients.delete(id));
    socket.pipe(deserializer).on('data', (rpc) => this.exec(rpc, id));
    serializer.pipe(socket);
  }

  /**
   * Using the RPC object and client ID, execute the api's method with args
   * and write the result back to the client socket
   * @param {object} rpc
   * @param {string} client
   */
  exec(rpc, client) {
    const self = this;
    const { serializer } = this.clients.get(client);
    const { type, payload } = rpc;

    if (type === 'notification') {
      let [,, streamId] = payload.method.split(':');
      let stream = this.streams.get(streamId);

      if (stream) {
        return payload.params.forEach((data) => {
          if (data === null) {
            stream.end();
          } else {
            stream.write(data);
          }
        });
      }

      this.emit('unhandled', rpc);
    }

    if (typeof this.api[payload.method] !== 'function') {
      return serializer.write(
        jsonrpc.error(payload.id, new jsonrpc.JsonRpcError(
          `Invalid method: "${payload.method}"`
        ))
      );
    }

    try {
      this.api[payload.method](...payload.params, handleResultCallback);
    } catch (err) {
      serializer.write(
        jsonrpc.error(payload.id, new jsonrpc.JsonRpcError(err.message))
      );
    }

    function handleResultCallback(err) {
      if (err) {
        return serializer.write(
          jsonrpc.error(payload.id, new jsonrpc.JsonRpcError(err.message))
        );
      }

      for (let a = 0; a < [...arguments].length; a++) {
        if (arguments[a] instanceof Stream) {
          arguments[a] = _createStreamPointer(self, arguments[a], serializer);
        }
      }

      serializer.write(jsonrpc.success(payload.id, [...arguments].slice(1)));
    }
  }

}

/**
 * Exposes a client control protocol interface for issuing commands
 * to a {@link Node}
 */
class ControlClient extends EventEmitter {

  /**
   * @constructor
   */
  constructor() {
    super();

    this.socket = new net.Socket();
    this.deserializer = new ControlDeserializer();
    this.serializer = new ControlSerializer();
    this._callbacks = new Map();
    this.streams = new Map();

    this.socket.on('connect', () => {
      this.socket.pipe(this.deserializer);
      this.serializer.pipe(this.socket);
      this.emit('ready');
    });
    this.socket.on('error', (err) => this.emit('error', err));
    this.deserializer.on('data', (rpc) => this._process(rpc));
  }

  /**
   * Opens a socket connection to the control port
   * @param {number} port
   */
  connect(port, address) {
    this.socket.connect(port, address);
  }

  /**
   * Processes received RPC messages from the control port
   * @private
   * @param {object} rpc
   */
  _process(rpc) {
    const { type, payload } = rpc;

    const handleResponse = () => {
      let callback = this._callbacks.get(payload.id);
      let { result } = payload;

      if (payload.result) {
        for (let p = 0; p < result.length; p++) {
          if (typeof result[p] === 'string' && result[p].includes('boscar:')) {
            let [, streamType, id] = result[p].split(':');
            let pointer = `boscar:${streamType}:${id}`;
            let stream = null;

            if (streamType === 'writable') {
              stream = result[p] = new Transform({
                write: (data, encoding, callback) => {
                  this.serializer.write(
                    jsonrpc.notification(pointer, [data])
                  );
                  callback();
                },
                flush: (callback) => {
                  this.serializer.write(
                    jsonrpc.notification(pointer, [null])
                  );
                  callback();
                },
                objectMode: true
              });

              stream.on('finish', () => this.streams.delete(id));
            } else {
              stream = result[p] = new Readable({
                read: () => null,
                objectMode: true
              });

              stream.on('end', () => this.streams.delete(id));
            }
            this.streams.set(id, stream);
          }
        }

        callback(null, ...payload.result);
      } else {
        callback(new Error(payload.error.message));
      }

      this._callbacks.delete(payload.id);
    };

    const handleNotification = () => {
      let [,, pointer] = payload.method.split(':');
      let stream = this.streams.get(pointer);

      if (!stream) {
        return this.emit('unhandled', rpc);
      }

      payload.params.forEach((param) => stream.push(param));
    };

    if (['success', 'error'].includes(type)) {
      handleResponse();
    } else if (type === 'notification') {
      handleNotification();
    } else {
      this.emit('unhandled', rpc);
    }
  }

  /**
   * Writes the appropriate payload to the serializer
   * @param {string} method
   * @param {array} params
   * @param {function} callback
   */
  invoke(method, params, callback) {
    const id = uuid();

    this._callbacks.set(id, callback);
    this.serializer.write(jsonrpc.request(id, method, params));
  }
}

module.exports = {
  Server: ControlServer,
  Client: ControlClient,
  Deserializer: ControlDeserializer,
  Serializer: ControlSerializer
};
