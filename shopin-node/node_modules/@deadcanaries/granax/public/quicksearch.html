<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" Granax Modules granaxgranax/commandsgranax/repliesgranax/torrc Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Getting Started Source: index.js /** * @module granax * @license AGPL-3.0 * @author Gordon Hall &lt;gordonh@member.fsf.org&gt; */ 'use strict'; const path = require('path'); const { spawn, execFileSync } = require('child_process'); const { platform } = require('os'); const { Socket } = require('net'); const { readFileSync } = require('fs'); const BIN_PATH = path.join(__dirname, 'bin'); const LD_LIBRARY_PATH = path.join( BIN_PATH, 'tor-browser_en-US', 'Browser', 'TorBrowser', 'Tor' ); /** * Returns a {@link TorController} with automatically constructed socket * to the local Tor bundle executable * @param {object} options * @param {object} torrcOptions * @returns {TorController} */ module.exports = function(options, torrcOptions) { let socket = new Socket(); let controller = new module.exports.TorController(socket, options); let [torrc, datadir] = module.exports.torrc(torrcOptions); let exe = path.basename(module.exports.tor(platform())); let tor = path.join(BIN_PATH, 'Tor', exe); let args = process.env.GRANAX_TOR_ARGS ? process.env.GRANAX_TOR_ARGS.split(' ') : []; let child = spawn(tor, ['-f', torrc].concat(args), { cwd: BIN_PATH, env: { LD_LIBRARY_PATH: path.join(BIN_PATH, 'Tor') } }); let portFileReads = 0; controller.process = child; // NB: Expose the tor process to userland function connect() { let port = null; try { port = parseInt(readFileSync(path.join( datadir, 'control-port' )).toString().split(':')[1]); } catch (err) { /* istanbul ignore next */ portFileReads++; /* istanbul ignore next */ if (portFileReads &lt;= 20) { return setTimeout(() =&gt; connect(), 1000); } else { return controller.emit('error', new Error('Failed to read control port')); } } socket.connect(port, '127.0.0.1'); } /* istanbul ignore next */ process.on('exit', () =&gt; child.kill()); child.stdout.once('data', () =&gt; setTimeout(() =&gt; connect(), 1000)); child.on('error', (err) =&gt; controller.emit('error', err)); child.on('exit', (code) =&gt; { controller.emit('error', new Error('Tor exited with code ' + code)); }); return controller; }; /** * Returns the local path to the tor bundle * @returns {string} */ module.exports.tor = function(platform) { /* eslint complexity: [\"error\", 7] */ let torpath = null; switch (platform) { case 'win32': torpath = path.join(BIN_PATH, 'Browser', 'TorBrowser', 'Tor', 'tor.exe'); break; case 'darwin': torpath = path.join(BIN_PATH, '.tbb.app', 'Contents', 'Resources', 'TorBrowser', 'Tor', 'tor'); break; case 'android': case 'linux': /* istanbul ignore else */ if (process.env.GRANAX_USE_SYSTEM_TOR) { // NB: Use the system Tor installation on android and linux try { torpath = execFileSync('which', ['tor']).toString().trim(); } catch (err) { /* istanbul ignore next */ throw new Error('Tor is not installed'); } } else { torpath = path.join(LD_LIBRARY_PATH, 'tor'); } break; default: throw new Error(`Unsupported platform \"${platform}\"`); } return torpath; }; /** * {@link TorController} */ module.exports.TorController = require('./lib/controller'); /** * {@link module:granax/commands} */ module.exports.commands = require('./lib/commands'); /** * {@link module:granax/replies} */ module.exports.replies = require('./lib/replies'); /** * {@link module:granax/torrc} */ module.exports.torrc = require('./lib/torrc'); Ã— Search results Close "},"lib_commands.js.html":{"id":"lib_commands.js.html","title":"Source: lib/commands.js","body":" Granax Modules granaxgranax/commandsgranax/repliesgranax/torrc Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Getting Started Source: lib/commands.js /** * @module granax/commands */ 'use strict'; const merge = require('merge'); /** * @param {string} [token=\"\"] - The auth token * @returns {string} */ exports.AUTHENTICATE = function(token = '') { return `AUTHENTICATE ${token}`; }; /** * @param {string} [nonce=\"\"] - Client nonce for challenge * @param {string} [type=\"SAFECOOKIE\"] - The type of challenge * @returns {string} */ exports.AUTHCHALLENGE = function(nonce = '', type = 'SAFECOOKIE') { return `AUTHCHALLENGE ${type} ${nonce}`; }; /** * @returns {string} */ exports.PROTOCOLINFO = function() { return 'PROTOCOLINFO'; }; const defaultOnionVirtualPort = 80; /** * @param {array} ports * @param {object} options * @param {array} command */ const _addOnionPortsStringToCommand = function(ports, opts, command) { if (opts.virtualPort) { command.push(`Port=${opts.virtualPort},${ports}`); } else { command.push(`Port=${defaultOnionVirtualPort},${ports}`); } } /** * @param {array} ports * @param {object} options * @param {array} command */ const _addOnionPortsToCommand = function(ports, opts, command) { if (typeof ports === 'string') { _addOnionPortsStringToCommand(ports, opts, command); return; } if (!ports.length) { command.push(`Port=${defaultOnionVirtualPort}`); return; } for (let port of ports) { let _portsString if (port.virtualPort) { _portsString = `Port=${port.virtualPort}`; } else { _portsString = `Port=${defaultOnionVirtualPort}`; } if (port.target) { _portsString += `,${port.target}`; } command.push(_portsString); } } /** * @param {array} ports - Array containing optional virtualPort (defaults to 80) and target ip:port string * @param {object} [options] * @param {string} [options.clientName] - Client auth identifier * @param {string} [options.clientBlob] - Arbitrary auth data * @param {string} [options.keyType=\"NEW\"] - Create a new key or use RSA1024 * @param {string} [options.keyBlob=\"BEST\"] - Key type to create or serialized * @param {boolean} [options.discardPrivateKey=false] - Do not return key * @param {boolean} [options.detach=false] - Keep service running after close * @param {boolean} [options.basicAuth=false] - Use client name and blob auth * @param {boolean} [options.nonAnonymous=false] - Non-anononymous mode */ exports.ADD_ONION = function(ports, opts = {}) { let options = merge({ clientName: null, clientBlob: null, keyType: 'NEW', keyBlob: 'BEST', discardPrivateKey: false, detach: false, basicAuth: false, nonAnonymous: false }, opts); let command = ['ADD_ONION', `${options.keyType}:${options.keyBlob}`]; let flagMap = [ ['discardPrivateKey', 'DiscardPK'], ['detach', 'Detach'], ['basicAuth', 'BasicAuth'], ['nonAnonymous', 'NonAnonymous'] ]; let flags = []; for (let flag of flagMap) { if (options[flag[0]]) { flags.push(flag[1]); } } if (flags.length) { command.push('Flags=' + flags.join(',')); } _addOnionPortsToCommand(ports, opts, command); if (options.clientName &amp;&amp; options.clientBlob) { command.push(`ClientAuth=${options.clientName}:${options.clientBlob}`); } return command.join(' '); }; /** * @param {string} serviceId * @returns {string} */ exports.DEL_ONION = function(serviceId) { return `DEL_ONION ${serviceId}`; }; /** * @param {string} keyword * @param {string} value * @returns {string} */ exports.SETCONF = function(keyword, value) { return `SETCONF ${keyword}=\"${value}\"`; }; /** * @param {string} keyword * @returns {string} */ exports.RESETCONF = function(keyword) { return `RESETCONF ${keyword}`; }; /** * @param {string} keyword * @returns {string} */ exports.GETCONF = function(keyword) { return `GETCONF ${keyword}`; }; /** * @returns {string} */ exports.SAVECONF = function() { return 'SAVECONF'; }; /** * @returns {string} */ exports.SIGNAL = function(signal) { return `SIGNAL ${signal}`; }; /** * @param {string} targetAddr * @param {string} replaceAddr * @returns {string} */ exports.MAPADDRESS = function(targetAddr, replaceAddr) { return `MAPADDRESS ${targetAddr}=${replaceAddr}`; }; /** * @param {string} circuitId * @returns {string} */ exports.EXTENDCIRCUIT = function(circuitId, purpose) { return `EXTENDCIRCUIT ${circuitId}` + (purpose ? ` purpose=\"${purpose}\"` : ''); }; /** * @param {string} circuitId * @param {string} purpose * */ exports.SETCIRCUITPURPOSE = function(circuitId, purpose) { return `SETCIRCUITPURPOSE ${circuitId} purpose=\"${purpose}\"`; }; /** * @param {string} streamId * @param {object} options * @param {string} options.circuitId * @param {string|null} options.hopNumber * @returns {string} */ exports.ATTACHSTREAM = function(streamId, options) { return `ATTACHSTREAM ${streamId} ${options.circuitId}` + (options.hopNumber ? ` HOP=${options.hopNumber}` : ''); }; /** * @param {object} descriptor * @param {object} options * @param {string} [options.purpose=\"general\"] * @param {boolean} [options.cache=true] * @returns {string} */ exports.POSTDESCRIPTOR = function(descriptor, options) { options = merge({ purpose: 'general', cache: true }, options); let descStrings = []; for (let key in descriptor) { descStrings.push(`${key}=${descriptor[key]}`); } return [ `+POSTDESCRIPTOR purpose=${options.purpose} ` + `cache=${options.cache ? 'yes' : 'no'}`, descStrings.join('\\r\\n'), '.' ].join('\\r\\n'); }; /** * @param {string} streamId * @param {string} address * @param {number} [port] * @returns {string} */ exports.REDIRECTSTREAM = function(streamId, address, port = '') { return `REDIRECTSTREAM ${streamId} ${address} ${port}`; }; /** * @param {string} streamId * @param {number} [reason=1] * @returns {string} */ exports.CLOSESTREAM = function(streamId, reason = 1) { return `CLOSESTREAM ${streamId} ${reason}`; }; /** * @param {string} circuitId * @param {object} [options] * @param {boolean} [options.ifUnused=false] * @returns {string} */ exports.CLOSECIRCUIT = function(circuitId, options = { ifUnused: false }) { return `CLOSECIRCUIT ${circuitId}` + (options.ifUnused ? ' IfUnused' : ''); }; /** * @returns {string} */ exports.QUIT = function() { return 'QUIT'; }; /** * @param {string} address * @param {boolean} [reverse=false] * @returns {string} */ exports.RESOLVE = function(address, reverse) { return 'RESOLVE ' + (reverse ? 'mode=reverse ' : '') + address; }; /** * @param {string} configText * @returns {string} */ exports.LOADCONF = function(configText) { return `+LOADCONF\\r\\n${configText}\\r\\n.`; }; /** * @returns {string} */ exports.TAKEOWNERSHIP = function() { return 'TAKEOWNERSHIP'; }; /** * @returns {string} */ exports.DROPGUARDS = function() { return 'DROPGUARDS'; }; /** * @param {string} serviceId * @param {string} [serverLongName] * @returns {string} */ exports.HSFETCH = function(serviceId, serverLongName) { return `HSFETCH ${serviceId}` + (serverLongName ? ` SERVER=${serverLongName}` : ''); }; /** * @param {string} descriptor * @param {string} [serverLongName] * @returns {string} */ exports.HSPOST = function(descriptor, serverLongName) { return '+HSPOST\\r\\n'+ (serverLongName ? `SERVER=${serverLongName}\\r\\n` : '') + `${descriptor}\\r\\n.`; }; /** * @param {string} keyword * @returns {string} */ exports.GETINFO = function(keyword) { return `GETINFO ${keyword}`; }; /** * @param {string[]} events * @returns {string} */ exports.SETEVENTS = function(events) { return `SETEVENTS ${events.join(' ')}`; }; Ã— Search results Close "},"lib_replies.js.html":{"id":"lib_replies.js.html","title":"Source: lib/replies.js","body":" Granax Modules granaxgranax/commandsgranax/repliesgranax/torrc Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Getting Started Source: lib/replies.js /** * @module granax/replies */ 'use strict'; /** * @param {string[]} output * @returns {AuthChallengeResult} */ exports.AUTHCHALLENGE = function(output) { let result = output[0].split(' '); let [, hash, nonce] = result; return { hash: hash.split('=').pop(), nonce: nonce ? nonce.split('=').pop() : null }; }; /** * @typedef {object} AuthChallengeResult * @property {string} hash - The server hash * @property {string} nonce - The server nonce */ /** * @param {string[]} output * @returns {ProtocolInfoResult} */ exports.PROTOCOLINFO = function(output) { let [proto, auth, version] = output; proto = proto.split(' '); auth = auth.split(' '); version = version.split(' '); return { protocol: proto[1], auth: { methods: auth[1].split('=')[1].split(','), cookieFile: auth[2] ? auth[2].split('=')[1].split('\"').join('') : null }, version: { tor: version[1].split('=')[1].split('\"').join('') } }; }; /** * @typedef {object} ProtocolInfoResult * @property {string} protocol * @property {object} auth * @property {string[]} auth.methods * @property {string} auth.cookieFile * @property {object} version * @property {string} version.tor */ /** * @param {string[]} output * @returns {AddOnionResult} */ exports.ADD_ONION = function(output) { return { serviceId: output[0].split('=')[1], privateKey: (output[1] &amp;&amp; output[1].includes('PrivateKey')) ? output[1].split('=')[1] : null }; }; /** * @typedef {object} AddOnionResult * @property {string} serviceId - The hidden service url without .onion * @property {string} [privateKey] - The generated private key */ /** * @param {string[]} output * @returns {GetConfigResult} */ exports.GETCONF = function(output) { return output.map((line) =&gt; line.split('=')[1]); }; /** * @typedef {string[]} GetConfigResult */ /** * @param {string[]} output * @returns {string} */ exports.GETINFO = function(output) { if (output.length &gt; 1) { return output.map((line) =&gt; line.split('=')[1]).join('\\n'); } return output[0].split('=')[1]; }; Ã— Search results Close "},"lib_torrc.js.html":{"id":"lib_torrc.js.html","title":"Source: lib/torrc.js","body":" Granax Modules granaxgranax/commandsgranax/repliesgranax/torrc Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Getting Started Source: lib/torrc.js /** * @module granax/torrc */ 'use strict'; const path = require('path'); const mkdirp = require('mkdirp'); const { randomBytes } = require('crypto'); const { tmpdir } = require('os'); const { writeFileSync } = require('fs'); /** * Generates a usable torrc file, writes it to temp storage and then returns * the path to the file * @param {object} options * @returns {string} */ module.exports = function(options = {}) { /* eslint max-statements: [2, 22] */ let id = randomBytes(8).toString('hex'); let dataDirectory = path.join(tmpdir(), `granax-${id}.d`); let torrcFile = path.join(tmpdir(), `granax-${id}`); let controlFilePath = path.join(dataDirectory, 'control-port'); let torrcContent = [ 'AvoidDiskWrites 1', 'SocksPort auto IPv6Traffic PreferIPv6 KeepAliveIsolateSOCKSAuth', 'ControlPort auto', 'CookieAuthentication 1' ]; if (!Array.isArray(options)) { options = [options]; } for (let block of options) { for (let property in block) { // NB: Don't push the DataDirectory until later so we can default it if (property === 'DataDirectory') { dataDirectory = block[property]; torrcFile = path.join(dataDirectory, 'torrc'); controlFilePath = path.join(dataDirectory, 'control-port') continue; } torrcContent.push(`${property} ${block[property]}`); } } torrcContent.push(`DataDirectory ${dataDirectory}`); torrcContent.push(`ControlPortWriteToFile ${controlFilePath}`); mkdirp.sync(dataDirectory); writeFileSync(torrcFile, torrcContent.join('\\n')); return [torrcFile, dataDirectory]; }; Ã— Search results Close "},"lib_controller.js.html":{"id":"lib_controller.js.html","title":"Source: lib/controller.js","body":" Granax Modules granaxgranax/commandsgranax/repliesgranax/torrc Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Getting Started Source: lib/controller.js 'use strict'; const crypto = require('crypto'); const async = require('async'); const { Transform: TransformStream } = require('stream'); const merge = require('merge'); const { readFileSync } = require('fs'); const { EventEmitter } = require('events'); const commands = require('./commands'); const replies = require('./replies'); /** * Represents a Tor controller for issuing commands */ class TorController extends EventEmitter { static get CLIENT_HASH() { return 'Tor safe cookie authentication controller-to-server hash'; } /** * Creates the challenge response from a SAFECOOKIE challenge * @param {string} cookie - The secret cookie string * @param {string} clientNonce - Client nonce sent with auth challenge * @param {string} serverNonce - Server nonce reply from auth challenge * @returns {string} */ static createChallengeResponse(cookie, clientNonce, serverNonce) { return crypto.createHmac('sha256', TorController.CLIENT_HASH) .update(Buffer.concat([ Buffer.from(cookie, 'hex'), Buffer.from(clientNonce, 'hex'), Buffer.from(serverNonce, 'hex') ])) .digest('hex'); } /** * Creates a message splitter from incoming socket data * @static */ static createReplySplitter() { return new TransformStream({ objectMode: true, transform: function(data, enc, next) { let reply = []; let lines = data.toString().split('\\r\\n'); for (let line of lines) { reply.push(line); if (line[3] === ' ') { this.push(reply); reply = []; } } next(null); } }); } /** * Fired when the underlying socket encounters an error * @event TorController#error * @type {error} */ /** * Fires when the controller is authenticated and ready to send commands * @event TorController#ready */ /** * Fires when the underlying socket closes * @event TorController#close */ static get DEFAULTS() { return { authOnConnect: true }; } /** * @constructor * @param {Socket} socket - net.Socket connected to Tor's control port * @param {object} [options] * @param {boolean} [options.authOnConnect=true] - Automatically authenticate */ constructor(socket, options) { super(); this._opts = merge(TorController.DEFAULTS, options); this._stack = []; this.socket = socket .on('connect', () =&gt; this._handleConnect()) .on('error', (err) =&gt; this._handleError(err)) .on('close', () =&gt; this._handleClose()); this.socket.pipe(TorController.createReplySplitter()) .on('data', (data) =&gt; this._handleReply(data)); } /** * Handles authentication routine on socket connect * @private * @param {function} callback */ _authOnConnect(callback) { const self = this; const clientNonce = crypto.randomBytes(32).toString('hex'); function maybeGetChallenge(cookie, authTypes, next) { if (authTypes.includes('SAFECOOKIE')) { self.getAuthChallenge(clientNonce, (err, result) =&gt; { next(err, result, cookie) }); } else { next(null, {}, cookie); } } function sendAuthCommand({ hash, nonce }, cookie, next) { if (!(hash &amp;&amp; nonce)) { return self.authenticate(cookie, next); } self.authenticate(TorController.createChallengeResponse( cookie, clientNonce, nonce, hash ), next); } async.waterfall([ (next) =&gt; this._getAuthCookie(next), (cookie, authTypes, next) =&gt; maybeGetChallenge(cookie, authTypes, next), (challenge, cookie, next) =&gt; sendAuthCommand(challenge, cookie, next) ], callback); } /** * Handles authentication upon socket connection * @private */ _handleConnect() { if (this._opts.authOnConnect) { this._authOnConnect((err) =&gt; this.emit(err ? 'error': 'ready', err)); } else { this.emit('ready'); } } /** * Handles errors on the underlying socket and bubbles them * @private * @param {object} error */ _handleError(err) { this.emit('error', err); } /** * Handles message processing and parsing from the socket * @private * @param {buffer} data */ _handleReply(data) { let code = parseInt(data[0].substr(0, 3)); let lines = data .filter((line) =&gt; !!line) .map((line) =&gt; line.substr(4).trim()); switch (code.toString()[0]) { case '2': let { method, callback } = this._stack.pop(); let parsed = replies[method] ? replies[method](lines) : lines; callback(null, parsed); break; case '4': case '5': this._stack.pop().callback(new Error(lines[0])); break; case '6': default: let event = lines[0].split(' ')[0]; lines[0] = lines[0].replace(`${event} `, ''); this.emit(event, lines); } } /** * Handles socket close event and bubbles it * @private */ _handleClose() { this.emit('close'); } /** * Send an arbitrary command and pass response to callback * @private * @param {string} command * @param {function} callback */ _send(command, callback) { const self = this; callback = callback || function(err) { /* istanbul ignore else */ if (err) { self.emit('error', err); } }; this._stack.unshift({ method: command.split(' ')[0], callback }); this.socket.write(`${command}\\r\\n`); } /** * Load the authentication cookie * @private * @param {TorController~_getAuthCookieCallback} callback */ _getAuthCookie(callback) { this.getProtocolInfo((err, info) =&gt; { if (err) { return callback(err); } try { callback( null, info.auth.cookieFile ? readFileSync(info.auth.cookieFile).toString('hex') : '', info.auth.methods ); } catch (err) { callback(err); } }); } /** * @private * @callback TorController~_getAuthCookieCallback * @param {object|null} error * @param {string} cookie * @param {string[]} authTypes */ /** * Authenticates with the control port given the supplied param * @param {string} token * @param {TorController~authenticateCallback} callback */ authenticate(token, callback) { this._send(commands.AUTHENTICATE(token), callback); } /** * Requests an authentication challenge from tor * @param {string} nonce - Client nonce for authenticating * @param {TorController~getAuthChallengeCallback} callback */ getAuthChallenge(nonce, callback) { this._send(commands.AUTHCHALLENGE(nonce), callback); } /** * @callback TorController~getAuthChallengeCallback * @param {object|null} error * @param {AuthChallengeResult} result */ /** * Ask tor for general information * @param {TorController~getProtocolInfoCallback} callback */ getProtocolInfo(callback) { this._send(commands.PROTOCOLINFO(), callback); } /** * @callback TorController~getProtocolInfoCallback * @param {object|null} error * @param {ProtocolInfoResult} result */ /** * Establishes a hidden service on the given target * @param {array} ports - Array containing optional virtualPort (defaults to 80) and target ip:port string * @param {object} [options] - {@link module:commands#ADD_ONION} * @param {TorController~createHiddenServiceCallback} callback */ createHiddenService(ports, options, callback) { /* istanbul ignore if */ if (typeof options === 'function') { callback = options; options = {}; } this._send(commands.ADD_ONION(ports, options), callback); } /** * @callback TorController~createHiddenServiceCallback * @param {object|null} error * @param {AddOnionResult} result */ /** * Takes down a running hidden service owned by this controller * @param {string} serviceId - Tor hidden service ID * @param {TorController~destroyHiddenServiceCallback} callback */ destroyHiddenService(serviceId, callback) { this._send(commands.DEL_ONION(serviceId), callback); } /** * @callback TorController~destroyHiddenServiceCallback * @param {object|null} error */ /** * Change the value for a configuration variable * @param {string} keyword - Configuration key * @param {string} value - New value to set * @param {TorController~setConfigCallback} callback */ setConfig(keyword, value, callback) { this._send(commands.SETCONF(keyword, value), callback); } /** * @callback TorController~setConfigCallback * @param {object|null} error */ /** * Change the value for a configuration variable to it's default * @param {string} keyword - Configuration key * @param {TorController~resetConfigCallback} callback */ resetConfig(keyword, callback) { this._send(commands.RESETCONF(keyword), callback); } /** * @callback TorController~resetConfigCallback * @param {object|null} error */ /** * Return the values for the given configuration key * @param {string} keyword - Configuration key * @param {TorController~getConfigCallback} callback */ getConfig(keyword, callback) { this._send(commands.GETCONF(keyword), callback); } /** * @callback TorController~getConfigCallback * @param {object|null} error * @param {GetConfigResult} result */ /** * Tell Tor to write out it's config value to it's torrc * @param {TorController~saveConfigCallback} callback */ saveConfig(callback) { this._send(commands.SAVECONF(), callback); } /** * @callback TorController~saveConfigCallback * @param {object|null} error */ /** * Reloads the config values set * @param {TorController~reloadConfigCallback} callback */ reloadConfig(callback) { this.signal('RELOAD', callback); } /** * @callback TorController~reloadConfigCallback * @param {object|null} error */ /** * Controlled shutdown signal * @param {TorController~shutdownCallback} callback */ shutdown(callback) { this.signal('SHUTDOWN', callback); } /** * @callback TorController~shutdownCallback * @param {object|null} error */ /** * Dump stats to tor log file * @param {TorController~dumpStatsCallback} callback */ dumpStats(callback) { this.signal('DUMP', callback); } /** * @callback TorController~dumpStatsCallback * @param {object|null} error */ /** * Set open logs to debug level * @param {TorController~enableDebugCallback} callback */ enableDebug(callback) { this.signal('DEBUG', callback); } /** * @callback TorController~enableDebugCallback * @param {object|null} error */ /** * Shutdown tor immediately * @param {TorController~haltCallback} callback */ halt(callback) { this.signal('HALT', callback); } /** * @callback TorController~haltCallback * @param {object|null} error */ /** * Forget client side hostname-&gt;ip cache * @param {TorController~clearDnsCacheCallback} callback */ clearDnsCache(callback) { this.signal('CLEARDNSCACHE', callback); } /** * @callback TorController~clearDnsCacheCallback * @param {object|null} error */ /** * Clears DNS cache and establishes new clean circuits * @param {TorController~cleanCircuitsCallback} callback */ cleanCircuits(callback) { this.signal('NEWNYM', callback); } /** * @callback TorController~cleanCircuitsCallback * @param {object|null} error */ /** * Dumps a heartbeat message to the logs * @param {TorController~dumpHeartbeatCallback} callback */ dumpHeartbeat(callback) { this.signal('HEARTBEAT', callback); } /** * @callback TorController~dumpHeartbeatCallback * @param {object|null} error */ /** * Sends a signal to the control port * @param {string} signal * @param {TorController~signalCallback} callback */ signal(sig, callback) { this._send(commands.SIGNAL(sig), callback); } /** * @callback TorController~signalCallback * @param {object|null} error */ /** * Instruct Tor to route requests to the target to the replacement * @param {string} target - Original address to map * @param {string} replacement - New address to route request to target * @param {TorController~createAddressMappingCallback} callback */ createAddressMapping(target, replacement, callback) { this._send(commands.MAPADDRESS(target, replacement), callback); } /** * @callback TorController~createAddressMappingCallback * @param {object|null} error */ /** * Creates a new circuit, returning the newly created circuit ID * @param {string} [purpose=\"general\"] - The circuit purpose, either general|controller * @param {TorController~createCircuitCallback} */ createCircuit(purpose, callback) { /* istanbul ignore if */ if (typeof purpose === 'function') { callback = purpose; purpose = null; } this._send(commands.EXTENDCIRCUIT('0', purpose), callback); } /** * @callback TorController~createCircuitCallback * @param {object|null} error * @param {string[]} result */ /** * Extends the existing circuit * @param {string} circuitId - The circuit ID to extend * @param {TorController~extendCircuitCallback} */ extendCircuit(id, callback) { this._send(commands.EXTENDCIRCUIT(id), callback); } /** * @callback TorController~extendCircuitCallback * @param {object|null} error * @param {string[]} result */ /** * Sets the purpose of the given circuit * @param {string} circuitId - The identifier for the circuit * @param {string} purpose - One of general|controller * @param {TorController~setCircuitPurposeCallback} callback */ setCircuitPurpose(circuitId, purpose, callback) { this._send(commands.SETCIRCUITPURPOSE(circuitId, purpose), callback); } /** * @callback TorController~setCircuitPurposeCallback * @param {object|null} error */ /** * Attaches the specified stream to the given circuit * @param {string} streamId - ID for the stream to attach * @param {string} [circuitId=0] - Circuit to attach stream * @param {number} [hopNumber] - Which hop to exit circuit * @param {TorController~attachStreamCallback} callback */ attachStream(streamId, options, callback) { /* istanbul ignore if */ if (typeof options === 'function') { callback = options; options = { circuitId: '0', hopNumber: null }; } this._send(commands.ATTACHSTREAM(streamId, options), callback); } /** * @callback TorController~attachStreamCallback * @param {object|null} error */ /** * Inform the server about a new descriptor * @param {object} descriptor - Key-value pairs for server descriptor * @param {object} [options] * @param {string} [options.purpose=\"general\"] - general|controller|bridge * @param {boolean} [options.cache=true] - Flag for caching descriptor * @param {TorController~postDescriptorCallback} callback */ postDescriptor(descriptor, options, callback) { /* istanbul ignore if */ if (typeof options === 'function') { callback = options; options = {}; } this._send(commands.POSTDESCRIPTOR(descriptor, options), callback); } /** * @callback TorController~postDescriptorCallback * @param {object|null} error */ /** * Change the exit address on a given stream * @param {string} streamId - ID for stream to redirect * @param {string} address - Exit address for the given stream * @param {number} [port] - Exit port for the given stream * @param {TorController~redirectStreamCallback} callback */ redirectStream(streamId, address, port, callback) { /* istanbul ignore if */ if (typeof port === 'function') { callback = port; port = null; } this._send(commands.REDIRECTSTREAM(streamId, address, port), callback); } /** * @callback TorController~redirectStreamCallback * @param {object|null} error */ /** * Closes the exit for the given stream * @param {string} streamId - ID for the stream to close * @param {number} [reason=1] - Reason code for closing stream * @param {TorController~closeStreamCallback} callback * @see https://gitweb.torproject.org/torspec.git/tree/tor-spec.txt#n1404 */ closeStream(streamId, reason, callback) { /* istanbul ignore if */ if (typeof reason === 'function') { callback = reason; reason = 1; } this._send(commands.CLOSESTREAM(streamId, reason), callback); } /** * @callback TorController~closeStreamCallback * @param {object|null} error */ /** * Closes the given circuit * @param {string} circuitId - ID for the circuit to close * @param {object} [options] * @param {boolean} [options.ifUnused=false] - Only close if not in use * @param {TorController~closeCircuitCallback} callback */ closeCicuit(circuitId, options, callback) { /* istanbul ignore if */ if (typeof options === 'function') { callback = options; options = { ifUnused: false }; } this._send(commands.CLOSECIRCUIT(circuitId, options), callback); } /** * @callback TorController~closeCircuitCallback * @param {object|null} error */ /** * Tells Tor to hang up on the controller * @param {TorController~quitCallback} callback */ quit(callback) { this._send(commands.QUIT(), callback); } /** * @callback TorController~quitCallback * @param {object|null} error */ /** * Launch remote hostname lookup - answer returnd as async ADDRMAP event * @param {string} address - Address to lookup * @param {object} [options] * @param {boolean} [options.reverse=false] - Perform reverse lookup * @param {TorController~resolveCallback} callback */ resolve(address, options, callback) { /* istanbul ignore if */ if (typeof options === 'function') { callback = options; options = {}; } this._send(commands.RESOLVE(address, options.reverse), callback); } /** * @callback TorController~resolveCallback * @param {object|null} error */ /** * Instruct Tor to load the configuration file from the given text * @param {string} configText - Complete torrc config text to load * @param {TorController~loadConfigCallback} callback */ loadConfig(configText, callback) { this._send(commands.LOADCONF(configText), callback); } /** * @callback TorController~loadConfigCallback * @param {object|null} error */ /** * Take ownership of the tor process - will close tor when the connection * closes * @param {TorController~takeOwnershipCallback} callback */ takeOwnership(callback) { this._send(commands.TAKEOWNERSHIP(), (err) =&gt; { /* istanbul ignore if */ if (err) { return callback(err); } this.resetConfig('__OwningControllerProcess', callback); }); } /** * @callback TorController~takeOwnershipCallback * @param {object|null} error */ /** * Tells the server to drop all guard nodes. Do not invoke this command * lightly; it can increase vulnerability to tracking attacks over time. * @param {TorController~dropGuardsCallback} callback */ dropGuards(callback) { this._send(commands.DROPGUARDS(), callback); } /** * @callback TorController~dropGuardsCallback * @param {object|null} error */ /** * Fetches descriptors for the given hidden service * @param {string} serviceId - ID for the hidden service * @param {string} [serverLongName] - Long name for specific server to use * @param {TorController~fetchHiddenServiceDescriptorCallback} callback */ fetchHiddenServiceDescriptor(serviceId, serverLongName, callback) { /* istanbul ignore if */ if (typeof serverLongName === 'function') { callback = serverLongName; serverLongName = ''; } this._send(commands.HSFETCH(serviceId, serverLongName), callback); } /** * @callback TorController~fetchHiddenServiceDescriptorCallback * @param {object|null} error */ /** * Launch a hidden service descriptor upload * @param {string} descriptor * @param {string} [serverLongName] - Long name for specific server to use * @param {TorController~postHiddenServiceDescriptorCallback} callback * @see https://gitweb.torproject.org/torspec.git/tree/rend-spec.txt#n193 */ postHiddenServiceDescriptor(descriptor, serverLongName, callback) { /* istanbul ignore if */ if (typeof serverLongName === 'function') { callback = serverLongName; serverLongName = ''; } this._send(commands.HSPOST(descriptor, serverLongName), callback); } /** * @callback TorController~postHiddenServiceDescriptorCallback * @param {object|null} error */ /** * Get information from Tor not stored in configuration * @param {string} keyword - Keyword for info to fetch * @param {TorController~getInfoCallback} callback * @see https://gitweb.torproject.org/torspec.git/tree/control-spec.txt#n500 */ getInfo(keyword, callback) { this._send(commands.GETINFO(keyword), callback); } /** * @callback TorController~getInfoCallback * @param {object|null} error * @param {string} result */ /** * Instructs Tor to send asynchronous events for the given types - these * events will be emitted from the controller. Calling this method resets * previously set event listeners * @param {string[]} events - List of event types to listen for * @param {TorController~addEventListenersCallback} callback * @see https://gitweb.torproject.org/torspec.git/tree/control-spec.txt#n1708 */ addEventListeners(events, callback) { this._send(commands.SETEVENTS(events), callback); } /** * @callback TorController~addEventListenersCallback * @param {object|null} error */ /** * Instructs Tor to stop listening for events * @param {TorController~removeEventListenersCallback} callback */ removeEventListeners(callback) { this._send(commands.SETEVENTS([]), callback); } /** * @callback TorController~removeEventListenersCallback * @param {object|null} error */ } module.exports = TorController; Ã— Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Granax Modules granaxgranax/commandsgranax/repliesgranax/torrc Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Getting Started Modules Classes TorController Events close Fires when the underlying socket closes Source: lib/controller.js error Fired when the underlying socket encounters an error Type: error Source: lib/controller.js ready Fires when the controller is authenticated and ready to send commands Source: lib/controller.js Ã— Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Granax Modules granaxgranax/commandsgranax/repliesgranax/torrc Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Getting Started Classes Classes TorController Events close Fires when the underlying socket closes Source: lib/controller.js error Fired when the underlying socket encounters an error Type: error Source: lib/controller.js ready Fires when the controller is authenticated and ready to send commands Source: lib/controller.js Ã— Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Granax Modules granaxgranax/commandsgranax/repliesgranax/torrc Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Getting Started Tutorials Classes TorController Events close Fires when the underlying socket closes Source: lib/controller.js error Fired when the underlying socket encounters an error Type: error Source: lib/controller.js ready Fires when the controller is authenticated and ready to send commands Source: lib/controller.js Ã— Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Granax Modules granaxgranax/commandsgranax/repliesgranax/torrc Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Getting Started GranaxComplete client implementation of the Tor Control Protocol. Control a running Tor instance from Node.js! UsageInstall via NPM: npm install granax --saveAs part of the installation process, Granax will download the Tor Browser Bundle local to itself and use the included Tor executable, however on GNU+Linux, you may opt for Granax to use the system Tor installed using your distribution's package manager by setting GRANAX_USE_SYSTEM_TOR=1. You can also tell Granax to install the latest alpha release of Tor instead of the latest stable release, with GRANAX_USE_TOR_ALPHA=1. const tor = require('granax')(); tor.on('ready', function() { tor.createHiddenService('127.0.0.1:8080', (err, result) =&gt; { console.info(`Service URL: ${result.serviceId}.onion`); console.info(`Private Key: ${result.privateKey}`); }); }); tor.on('error', function(err) { console.error(err); });Using System Tor PackageMake sure that ControlPort=9051 (or your preferred port) is set in your torrc, then you may open the control socket and issue commands: const { connect } = require('net'); const { TorController } = require('granax'); const tor = new TorController(connect(9051), options); tor.on('ready', function() { // party! }); Note that if using cookie authentication, the Node.js process must have the appropriate privileges to read the cookie file. Usually, this means running as the same user that is running Tor. Resources Granax Source Granax Examples Granax Documentation Tor Control Specification Tor Documentation LicenseGranax - Complete client implementation of the Tor Control ProtocolCopyright (C) 2017 Gordon Hall This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero General Public License along with this program. If not, see http://www.gnu.org/licenses/. Ã— Search results Close "},"module-granax.html":{"id":"module-granax.html","title":"Module: granax","body":" Granax Modules granaxgranax/commandsgranax/repliesgranax/torrc Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Getting Started Module: granax (require(\"granax\"))(options, torrcOptions) Returns a TorController with automatically constructed socket to the local Tor bundle executable Parameters: Name Type Description options object torrcOptions object Source: index.js Returns: Type TorController Members &lt;static&gt; commands module:granax/commands Source: index.js &lt;static&gt; replies module:granax/replies Source: index.js &lt;static&gt; TorController TorController Source: index.js &lt;static&gt; torrc module:granax/torrc Source: index.js Methods &lt;static&gt; tor() Returns the local path to the tor bundle Source: index.js Returns: Type string Ã— Search results Close "},"module-granax_commands.html":{"id":"module-granax_commands.html","title":"Module: granax/commands","body":" Granax Modules granaxgranax/commandsgranax/repliesgranax/torrc Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Getting Started Module: granax/commands Source: lib/commands.js Methods &lt;static&gt; ADD_ONION(ports [, options]) Parameters: Name Type Argument Description ports array Array containing optional virtualPort (defaults to 80) and target ip:port string options object &lt;optional&gt; Properties Name Type Argument Default Description clientName string &lt;optional&gt; Client auth identifier clientBlob string &lt;optional&gt; Arbitrary auth data keyType string &lt;optional&gt; \"NEW\" Create a new key or use RSA1024 keyBlob string &lt;optional&gt; \"BEST\" Key type to create or serialized discardPrivateKey boolean &lt;optional&gt; false Do not return key detach boolean &lt;optional&gt; false Keep service running after close basicAuth boolean &lt;optional&gt; false Use client name and blob auth nonAnonymous boolean &lt;optional&gt; false Non-anononymous mode Source: lib/commands.js &lt;static&gt; ATTACHSTREAM(streamId, options) Parameters: Name Type Description streamId string options object Properties Name Type Description circuitId string hopNumber string | null Source: lib/commands.js Returns: Type string &lt;static&gt; AUTHCHALLENGE( [nonce] [, type]) Parameters: Name Type Argument Default Description nonce string &lt;optional&gt; \"\" Client nonce for challenge type string &lt;optional&gt; \"SAFECOOKIE\" The type of challenge Source: lib/commands.js Returns: Type string &lt;static&gt; AUTHENTICATE( [token]) Parameters: Name Type Argument Default Description token string &lt;optional&gt; \"\" The auth token Source: lib/commands.js Returns: Type string &lt;static&gt; CLOSECIRCUIT(circuitId [, options]) Parameters: Name Type Argument Description circuitId string options object &lt;optional&gt; Properties Name Type Argument Default Description ifUnused boolean &lt;optional&gt; false Source: lib/commands.js Returns: Type string &lt;static&gt; CLOSESTREAM(streamId [, reason]) Parameters: Name Type Argument Default Description streamId string reason number &lt;optional&gt; 1 Source: lib/commands.js Returns: Type string &lt;static&gt; DEL_ONION(serviceId) Parameters: Name Type Description serviceId string Source: lib/commands.js Returns: Type string &lt;static&gt; DROPGUARDS() Source: lib/commands.js Returns: Type string &lt;static&gt; EXTENDCIRCUIT(circuitId) Parameters: Name Type Description circuitId string Source: lib/commands.js Returns: Type string &lt;static&gt; GETCONF(keyword) Parameters: Name Type Description keyword string Source: lib/commands.js Returns: Type string &lt;static&gt; GETINFO(keyword) Parameters: Name Type Description keyword string Source: lib/commands.js Returns: Type string &lt;static&gt; HSFETCH(serviceId [, serverLongName]) Parameters: Name Type Argument Description serviceId string serverLongName string &lt;optional&gt; Source: lib/commands.js Returns: Type string &lt;static&gt; HSPOST(descriptor [, serverLongName]) Parameters: Name Type Argument Description descriptor string serverLongName string &lt;optional&gt; Source: lib/commands.js Returns: Type string &lt;static&gt; LOADCONF(configText) Parameters: Name Type Description configText string Source: lib/commands.js Returns: Type string &lt;static&gt; MAPADDRESS(targetAddr, replaceAddr) Parameters: Name Type Description targetAddr string replaceAddr string Source: lib/commands.js Returns: Type string &lt;static&gt; POSTDESCRIPTOR(descriptor, options) Parameters: Name Type Description descriptor object options object Properties Name Type Argument Default Description purpose string &lt;optional&gt; \"general\" cache boolean &lt;optional&gt; true Source: lib/commands.js Returns: Type string &lt;static&gt; PROTOCOLINFO() Source: lib/commands.js Returns: Type string &lt;static&gt; QUIT() Source: lib/commands.js Returns: Type string &lt;static&gt; REDIRECTSTREAM(streamId, address [, port]) Parameters: Name Type Argument Description streamId string address string port number &lt;optional&gt; Source: lib/commands.js Returns: Type string &lt;static&gt; RESETCONF(keyword) Parameters: Name Type Description keyword string Source: lib/commands.js Returns: Type string &lt;static&gt; RESOLVE(address [, reverse]) Parameters: Name Type Argument Default Description address string reverse boolean &lt;optional&gt; false Source: lib/commands.js Returns: Type string &lt;static&gt; SAVECONF() Source: lib/commands.js Returns: Type string &lt;static&gt; SETCIRCUITPURPOSE(circuitId, purpose) Parameters: Name Type Description circuitId string purpose string Source: lib/commands.js &lt;static&gt; SETCONF(keyword, value) Parameters: Name Type Description keyword string value string Source: lib/commands.js Returns: Type string &lt;static&gt; SETEVENTS(events) Parameters: Name Type Description events Array.&lt;string&gt; Source: lib/commands.js Returns: Type string &lt;static&gt; SIGNAL() Source: lib/commands.js Returns: Type string &lt;static&gt; TAKEOWNERSHIP() Source: lib/commands.js Returns: Type string &lt;inner&gt; _addOnionPortsStringToCommand(ports, options, command) Parameters: Name Type Description ports array options object command array Source: lib/commands.js &lt;inner&gt; _addOnionPortsToCommand(ports, options, command) Parameters: Name Type Description ports array options object command array Source: lib/commands.js Ã— Search results Close "},"module-granax_replies.html":{"id":"module-granax_replies.html","title":"Module: granax/replies","body":" Granax Modules granaxgranax/commandsgranax/repliesgranax/torrc Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Getting Started Module: granax/replies Source: lib/replies.js Methods &lt;static&gt; ADD_ONION(output) Parameters: Name Type Description output Array.&lt;string&gt; Source: lib/replies.js Returns: Type AddOnionResult &lt;static&gt; AUTHCHALLENGE(output) Parameters: Name Type Description output Array.&lt;string&gt; Source: lib/replies.js Returns: Type AuthChallengeResult &lt;static&gt; GETCONF(output) Parameters: Name Type Description output Array.&lt;string&gt; Source: lib/replies.js Returns: Type GetConfigResult &lt;static&gt; GETINFO(output) Parameters: Name Type Description output Array.&lt;string&gt; Source: lib/replies.js Returns: Type string &lt;static&gt; PROTOCOLINFO(output) Parameters: Name Type Description output Array.&lt;string&gt; Source: lib/replies.js Returns: Type ProtocolInfoResult Type Definitions AddOnionResult Type: object Properties: Name Type Argument Description serviceId string The hidden service url without .onion privateKey string &lt;optional&gt; The generated private key Source: lib/replies.js AuthChallengeResult Type: object Properties: Name Type Description hash string The server hash nonce string The server nonce Source: lib/replies.js GetConfigResult Type: Array.&lt;string&gt; Source: lib/replies.js ProtocolInfoResult Type: object Properties: Name Type Description protocol string auth object Properties Name Type Description methods Array.&lt;string&gt; cookieFile string version object Properties Name Type Description tor string Source: lib/replies.js Ã— Search results Close "},"module-granax_torrc.html":{"id":"module-granax_torrc.html","title":"Module: granax/torrc","body":" Granax Modules granaxgranax/commandsgranax/repliesgranax/torrc Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Getting Started Module: granax/torrc (require(\"granax/torrc\"))(options) Generates a usable torrc file, writes it to temp storage and then returns the path to the file Parameters: Name Type Description options object Source: lib/torrc.js Returns: Type string Ã— Search results Close "},"TorController.html":{"id":"TorController.html","title":"Class: TorController","body":" Granax Modules granaxgranax/commandsgranax/repliesgranax/torrc Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Getting Started Class: TorController TorController Represents a Tor controller for issuing commands new TorController(socket [, options]) Parameters: Name Type Argument Description socket Socket net.Socket connected to Tor's control port options object &lt;optional&gt; Properties Name Type Argument Default Description authOnConnect boolean &lt;optional&gt; true Automatically authenticate Source: lib/controller.js Methods &lt;static&gt; createChallengeResponse(cookie, clientNonce, serverNonce) Creates the challenge response from a SAFECOOKIE challenge Parameters: Name Type Description cookie string The secret cookie string clientNonce string Client nonce sent with auth challenge serverNonce string Server nonce reply from auth challenge Source: lib/controller.js Returns: Type string &lt;static&gt; createReplySplitter() Creates a message splitter from incoming socket data Source: lib/controller.js addEventListeners(events, callback) Instructs Tor to send asynchronous events for the given types - these events will be emitted from the controller. Calling this method resets previously set event listeners Parameters: Name Type Description events Array.&lt;string&gt; List of event types to listen for callback TorController~addEventListenersCallback Source: lib/controller.js See: https://gitweb.torproject.org/torspec.git/tree/control-spec.txt#n1708 attachStream(streamId [, circuitId] [, hopNumber], callback) Attaches the specified stream to the given circuit Parameters: Name Type Argument Default Description streamId string ID for the stream to attach circuitId string &lt;optional&gt; 0 Circuit to attach stream hopNumber number &lt;optional&gt; Which hop to exit circuit callback TorController~attachStreamCallback Source: lib/controller.js authenticate(token, callback) Authenticates with the control port given the supplied param Parameters: Name Type Description token string callback TorController~authenticateCallback Source: lib/controller.js cleanCircuits(callback) Clears DNS cache and establishes new clean circuits Parameters: Name Type Description callback TorController~cleanCircuitsCallback Source: lib/controller.js clearDnsCache(callback) Forget client side hostname-&gt;ip cache Parameters: Name Type Description callback TorController~clearDnsCacheCallback Source: lib/controller.js closeCicuit(circuitId [, options], callback) Closes the given circuit Parameters: Name Type Argument Description circuitId string ID for the circuit to close options object &lt;optional&gt; Properties Name Type Argument Default Description ifUnused boolean &lt;optional&gt; false Only close if not in use callback TorController~closeCircuitCallback Source: lib/controller.js closeStream(streamId [, reason], callback) Closes the exit for the given stream Parameters: Name Type Argument Default Description streamId string ID for the stream to close reason number &lt;optional&gt; 1 Reason code for closing stream callback TorController~closeStreamCallback Source: lib/controller.js See: https://gitweb.torproject.org/torspec.git/tree/tor-spec.txt#n1404 createAddressMapping(target, replacement, callback) Instruct Tor to route requests to the target to the replacement Parameters: Name Type Description target string Original address to map replacement string New address to route request to target callback TorController~createAddressMappingCallback Source: lib/controller.js createCircuit( [purpose], callback) Creates a new circuit, returning the newly created circuit ID Parameters: Name Type Argument Default Description purpose string &lt;optional&gt; \"general\" The circuit purpose, either general|controller callback TorController~createCircuitCallback Source: lib/controller.js createHiddenService(ports [, options], callback) Establishes a hidden service on the given target Parameters: Name Type Argument Description ports array Array containing optional virtualPort (defaults to 80) and target ip:port string options object &lt;optional&gt; module:commands#ADD_ONION callback TorController~createHiddenServiceCallback Source: lib/controller.js destroyHiddenService(serviceId, callback) Takes down a running hidden service owned by this controller Parameters: Name Type Description serviceId string Tor hidden service ID callback TorController~destroyHiddenServiceCallback Source: lib/controller.js dropGuards(callback) Tells the server to drop all guard nodes. Do not invoke this command lightly; it can increase vulnerability to tracking attacks over time. Parameters: Name Type Description callback TorController~dropGuardsCallback Source: lib/controller.js dumpHeartbeat(callback) Dumps a heartbeat message to the logs Parameters: Name Type Description callback TorController~dumpHeartbeatCallback Source: lib/controller.js dumpStats(callback) Dump stats to tor log file Parameters: Name Type Description callback TorController~dumpStatsCallback Source: lib/controller.js enableDebug(callback) Set open logs to debug level Parameters: Name Type Description callback TorController~enableDebugCallback Source: lib/controller.js extendCircuit(circuitId, callback) Extends the existing circuit Parameters: Name Type Description circuitId string The circuit ID to extend callback TorController~extendCircuitCallback Source: lib/controller.js fetchHiddenServiceDescriptor(serviceId [, serverLongName], callback) Fetches descriptors for the given hidden service Parameters: Name Type Argument Description serviceId string ID for the hidden service serverLongName string &lt;optional&gt; Long name for specific server to use callback TorController~fetchHiddenServiceDescriptorCallback Source: lib/controller.js getAuthChallenge(nonce, callback) Requests an authentication challenge from tor Parameters: Name Type Description nonce string Client nonce for authenticating callback TorController~getAuthChallengeCallback Source: lib/controller.js getConfig(keyword, callback) Return the values for the given configuration key Parameters: Name Type Description keyword string Configuration key callback TorController~getConfigCallback Source: lib/controller.js getInfo(keyword, callback) Get information from Tor not stored in configuration Parameters: Name Type Description keyword string Keyword for info to fetch callback TorController~getInfoCallback Source: lib/controller.js See: https://gitweb.torproject.org/torspec.git/tree/control-spec.txt#n500 getProtocolInfo(callback) Ask tor for general information Parameters: Name Type Description callback TorController~getProtocolInfoCallback Source: lib/controller.js halt(callback) Shutdown tor immediately Parameters: Name Type Description callback TorController~haltCallback Source: lib/controller.js loadConfig(configText, callback) Instruct Tor to load the configuration file from the given text Parameters: Name Type Description configText string Complete torrc config text to load callback TorController~loadConfigCallback Source: lib/controller.js postDescriptor(descriptor [, options], callback) Inform the server about a new descriptor Parameters: Name Type Argument Description descriptor object Key-value pairs for server descriptor options object &lt;optional&gt; Properties Name Type Argument Default Description purpose string &lt;optional&gt; \"general\" general|controller|bridge cache boolean &lt;optional&gt; true Flag for caching descriptor callback TorController~postDescriptorCallback Source: lib/controller.js postHiddenServiceDescriptor(descriptor [, serverLongName], callback) Launch a hidden service descriptor upload Parameters: Name Type Argument Description descriptor string serverLongName string &lt;optional&gt; Long name for specific server to use callback TorController~postHiddenServiceDescriptorCallback Source: lib/controller.js See: https://gitweb.torproject.org/torspec.git/tree/rend-spec.txt#n193 quit(callback) Tells Tor to hang up on the controller Parameters: Name Type Description callback TorController~quitCallback Source: lib/controller.js redirectStream(streamId, address [, port], callback) Change the exit address on a given stream Parameters: Name Type Argument Description streamId string ID for stream to redirect address string Exit address for the given stream port number &lt;optional&gt; Exit port for the given stream callback TorController~redirectStreamCallback Source: lib/controller.js reloadConfig(callback) Reloads the config values set Parameters: Name Type Description callback TorController~reloadConfigCallback Source: lib/controller.js removeEventListeners(callback) Instructs Tor to stop listening for events Parameters: Name Type Description callback TorController~removeEventListenersCallback Source: lib/controller.js resetConfig(keyword, callback) Change the value for a configuration variable to it's default Parameters: Name Type Description keyword string Configuration key callback TorController~resetConfigCallback Source: lib/controller.js resolve(address [, options], callback) Launch remote hostname lookup - answer returnd as async ADDRMAP event Parameters: Name Type Argument Description address string Address to lookup options object &lt;optional&gt; Properties Name Type Argument Default Description reverse boolean &lt;optional&gt; false Perform reverse lookup callback TorController~resolveCallback Source: lib/controller.js saveConfig(callback) Tell Tor to write out it's config value to it's torrc Parameters: Name Type Description callback TorController~saveConfigCallback Source: lib/controller.js setCircuitPurpose(circuitId, purpose, callback) Sets the purpose of the given circuit Parameters: Name Type Description circuitId string The identifier for the circuit purpose string One of general|controller callback TorController~setCircuitPurposeCallback Source: lib/controller.js setConfig(keyword, value, callback) Change the value for a configuration variable Parameters: Name Type Description keyword string Configuration key value string New value to set callback TorController~setConfigCallback Source: lib/controller.js shutdown(callback) Controlled shutdown signal Parameters: Name Type Description callback TorController~shutdownCallback Source: lib/controller.js signal(signal, callback) Sends a signal to the control port Parameters: Name Type Description signal string callback TorController~signalCallback Source: lib/controller.js takeOwnership(callback) Take ownership of the tor process - will close tor when the connection closes Parameters: Name Type Description callback TorController~takeOwnershipCallback Source: lib/controller.js Type Definitions addEventListenersCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js attachStreamCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js cleanCircuitsCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js clearDnsCacheCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js closeCircuitCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js closeStreamCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js createAddressMappingCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js createCircuitCallback(error, result) Parameters: Name Type Description error object | null result Array.&lt;string&gt; Source: lib/controller.js createHiddenServiceCallback(error, result) Parameters: Name Type Description error object | null result AddOnionResult Source: lib/controller.js destroyHiddenServiceCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js dropGuardsCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js dumpHeartbeatCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js dumpStatsCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js enableDebugCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js extendCircuitCallback(error, result) Parameters: Name Type Description error object | null result Array.&lt;string&gt; Source: lib/controller.js fetchHiddenServiceDescriptorCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js getAuthChallengeCallback(error, result) Parameters: Name Type Description error object | null result AuthChallengeResult Source: lib/controller.js getConfigCallback(error, result) Parameters: Name Type Description error object | null result GetConfigResult Source: lib/controller.js getInfoCallback(error, result) Parameters: Name Type Description error object | null result string Source: lib/controller.js getProtocolInfoCallback(error, result) Parameters: Name Type Description error object | null result ProtocolInfoResult Source: lib/controller.js haltCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js loadConfigCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js postDescriptorCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js postHiddenServiceDescriptorCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js quitCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js redirectStreamCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js reloadConfigCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js resetConfigCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js resolveCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js saveConfigCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js setCircuitPurposeCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js setConfigCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js shutdownCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js signalCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js takeOwnershipCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js Events close Fires when the underlying socket closes Source: lib/controller.js error Fired when the underlying socket encounters an error Type: error Source: lib/controller.js ready Fires when the controller is authenticated and ready to send commands Source: lib/controller.js Ã— Search results Close "},"tutorial-getting-started.html":{"id":"tutorial-getting-started.html","title":"Tutorial: Getting Started","body":" Granax Modules granaxgranax/commandsgranax/repliesgranax/torrc Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Getting Started Getting Started When Granax is installed on Mac OSX or Windows platforms, it will automatically download a copy of the Tor Browser Bundle locally and use it - no configuration required! On GNU+Linux systems, Granax expects the tor package to be installed. Granax will start Tor with a custom torrc file that can be found in lib/torrc.js, however if you prefer to use a custom torrc or a different Tor executable, follow this guide. This guide assumes you are running Debian or a derivitive, however it should translate easily to any other operating system. Step 0: Install TorUse your system's package manager to install the latest Tor release: sudo apt install tor See https://www.torproject.org/docs/installguide.html.en Step 1: Give User AccessOn Debian systems, Tor is compartmentalized for security. You'll need to be able to read Tor's authentication cookie file. There are a couple ways to do this without running Granax as root. Run your program as the debian-tor user: sudo -u debian-tor /path/to/nodejs granax/examples/hidden-service.jsAdd your user to the debian-tor group: sudo adduser $USER debian-torThen log out and back in and Granax will be able to access Tor's control interface. Step 2: Enable Tor's Control InterfaceBy default, Tor does not enable the control port, so you must enable it in your torrc file. sudo vim /etc/tor/torrc Don't know where your torrc is? See https://www.torproject.org/docs/faq#torrc Find the section that contains the text below. ## The port on which Tor will listen for local connections from Tor ## controller applications, as documented in control-spec.txt. #ControlPort 9051 ## If you enable the controlport, be sure to enable one of these ## authentication methods, to prevent attackers from accessing it. #HashedControlPassword 16:872860B76453A77D60CA2BB8C1A7042072093276A3D701AD684053EC4C #CookieAuthentication 1And uncomment ControlPort 9051 and CookieAuthentication 1. ## The port on which Tor will listen for local connections from Tor ## controller applications, as documented in control-spec.txt. ControlPort 9051 ## If you enable the controlport, be sure to enable one of these ## authentication methods, to prevent attackers from accessing it. #HashedControlPassword 16:872860B76453A77D60CA2BB8C1A7042072093276A3D701AD684053EC4C CookieAuthentication 1Write the changes and restart Tor. sudo /etc/init.d/tor restartStep 3: Hack The PlanetNow that you have a running Tor, configured to allow your user to access it's control port, you can integrate Tor into your own packages using Granax! const { connect } = require('net'); const { TorController } = require('granax'); const tor = new TorController(connect(9051)); tor.on('ready', function() { // Tor controller is ready! });Happy hacking! Ã— Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
