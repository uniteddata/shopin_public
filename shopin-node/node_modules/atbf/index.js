'use strict';

const { Bloem: BloomFilter } = require('bloem');


/**
 * Represents an attenuated bloom filter
 * @class
 */
class AttenuatedBloomFilter extends Array {

  static get [Symbol.species]() {
    return Array;
  }

  /**
   * Constructs an empty attenuated bloom filter given a bitfield size
   * and a filter depth
   * @constructor
   */
  constructor(options = {}) {
    super();

    this.bitfieldSize = options.bitfieldSize || 160;
    this.filterDepth = options.filterDepth || 3;

    for (let i = 0; i < this.filterDepth; i++) {
      this.push(new BloomFilter(this.bitfieldSize, 2));
    }
  }

  /**
   * Returns a comma delimited string of each filter serialized to hex strings
   * @returns {string}
   */
  toString() {
    return this.toHexArray().toString();
  }

  /**
   * Returns an array of hex string serialized filters
   * @returns {string[]}
   */
  toHexArray() {
    return this.map(
      (bloomFilter) => bloomFilter.bitfield.toBuffer().toString('hex')
    );
  }

  /**
   * Merges a foreign attenuated filter into ours
   * @param {AttenuatedBloomFilter} foreignFilters - The attenuated filter to
   * merge into ours (uses bitwise OR operation)
   * @returns {AttenuatedBloomFilter} this
   */
  merge(foreignFilters) {
    for (let [localIndex, localFilter] of this.entries()) {
      if (localIndex === 0) {
        continue;
      }

      let foreignFilter = foreignFilters[localIndex - 1];
      let { data: foreignFilterBytes } = foreignFilter.bitfield.buffer.toJSON();
      let localFilterBuffer = localFilter.bitfield.buffer;

      if (!foreignFilters[localIndex - 1]) {
        return this;
      }

      for (let [bytePos, byteValue] of foreignFilterBytes.entries()) {
        localFilterBuffer[bytePos] = localFilterBuffer[bytePos] | byteValue;
      }
    }

    return this;
  }

  /**
   * Constructs a attentuated bloom filter from a array of hex strings
   * @static
   * @memberof AttenuatedBloomFilter
   * @param {string[]} hexFilters
   */
  static from(hexFilters) {
    const filters = new AttenuatedBloomFilter({
      bitfieldSize: Buffer.from(hexFilters[0], 'hex').length * 8,
      filterDepth: hexFilters.length
    });

    hexFilters.forEach((hexString, i) => {
      filters[i].bitfield.buffer = Buffer.from(hexString, 'hex')
    });

    return filters;
  }

}

module.exports = AttenuatedBloomFilter;
