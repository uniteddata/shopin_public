'use strict';

const { Transform, PassThrough } = require('stream');
const { EventEmitter } = require('events');


/**
 * Represents a pipeline of tranform streams
 */
class MetaPipe extends Transform {

  /**
   * @constructor
   * @param {object} [options]
   * @param {boolean} [options.objectMode=false]
   */
  constructor(options = {}) {
    super(options);
    this._errors = new EventEmitter();
    this.pipeline = [new PassThrough(options)];
  }

  /**
   * Adds a new transform stream to the pipeline end
   * @param {stream.Transform} stream
   */
  append(stream) {
    stream.on('error', (err) => this._errors.emit('error', err));
    stream.on('unpipe', (source) => source.pipe(stream));
    this.pipeline[this.pipeline.length - 1].pipe(stream);
    this.pipeline.push(stream);
  }

  /**
   * Adds a new transform stream to the pipeline front
   * @param {stream.Transform} stream
   */
  prepend(stream) {
    stream.on('error', (err) => this._errors.emit('error', err));
    stream.on('unpipe', (source) => source.pipe(stream));
    stream.pipe(this.pipeline[0]);
    this.pipeline.unshift(stream);
  }

  /**
   * @private
   */
  _transform(data, encoding, callback) {
    this.pipeline[this.pipeline.length - 1].once('data', data => {
      this._errors.removeAllListeners();
      callback(null, data);
    });
    this._errors.once('error', err => {
      this.pipeline[this.pipeline.length - 1].removeAllListeners();
      callback(err);
    });
    this.pipeline[0].write(data);
  }

  /**
   * @private
   */
  _flush(callback) {
    for (let i = 0; i < this.pipeline.length; i++) {
      let stream = this.pipeline[i];

      if (this.pipeline[i + 1]) {
        stream.removeAllListeners('unpipe');
        stream.unpipe(this.pipeline[i + 1]);
      } else {
        callback();
      }
    }
  }

}

module.exports = MetaPipe;
